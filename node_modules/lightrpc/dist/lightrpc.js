(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.LightRPC = factory());
}(this, (function () { 'use strict';

  /**
   * Adds timeout to promise.
   * @param {number} timeout Timeout in miliseconds.
   * @param {Promise} promise Promise to wrap in timeout
   * @returns {Promise} A promise that will fail if it doesn't resolve or reject in specified timeout
   */
  function createTimeout(timeout, promise) {
    return new Promise(function (resolve, reject) {
      setTimeout(function () {
        reject(new Error("Request has timed out. It should take no longer than " + timeout + "ms."));
      }, timeout);
      promise.then(resolve, reject);
    });
  }

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var fetch = void 0;
  if (typeof window !== 'undefined' && window.fetch) {
    var _window = window;
    fetch = _window.fetch;
  } else {
    fetch = require('cross-fetch'); // eslint-disable-line global-require
  }

  var Client = function () {
    function Client(address) {
      var defaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      classCallCheck(this, Client);

      if (typeof address !== 'string') throw new Error('InvalidArgument: address has to ba a string');
      if ((typeof defaultOptions === 'undefined' ? 'undefined' : _typeof(defaultOptions)) !== 'object') throw new Error('InvalidArgument: defaultOptions has to be an object');

      this.address = address;

      this.options = _extends({
        timeout: 5000,
        headers: { 'Content-Type': 'application/json' }
      }, defaultOptions);

      this.fetchURL = this.fetchURL.bind(this);
      this.send = this.send.bind(this);
    }

    createClass(Client, [{
      key: 'fetchURL',
      value: function fetchURL(request, options) {
        return fetch(this.address, {
          body: JSON.stringify(request),
          headers: options.headers,
          method: 'post',
          mode: 'cors'
        });
      }
    }, {
      key: 'call',
      value: function call(method, params, requestOptions, callback) {
        var effectiveCallback = typeof requestOptions === 'function' ? requestOptions : callback;

        this.send({ method: method, params: params }, requestOptions, effectiveCallback);
      }
    }, {
      key: 'send',
      value: function send(request, requestOptions, callback) {
        var effectiveCallback = typeof requestOptions === 'function' ? requestOptions : callback;

        var usedOptions = this.options;
        if ((typeof requestOptions === 'undefined' ? 'undefined' : _typeof(requestOptions)) === 'object') {
          usedOptions = _extends({}, usedOptions, requestOptions);
        }

        var rpcRequest = _extends({
          jsonrpc: '2.0'
        }, request);

        createTimeout(usedOptions.timeout, this.fetchURL(rpcRequest, usedOptions)).then(function (res) {
          return res.json();
        }).then(function (res) {
          if (res.error) {
            throw new Error('Response contains error', res.error);
          }

          if (!res.result) {
            throw new Error("Response doesn't contain results");
          }

          return res;
        }).then(function (res) {
          effectiveCallback(null, res.result);
        }).catch(function (err) {
          return effectiveCallback(err, null);
        });
      }
    }, {
      key: 'sendBatch',
      value: function sendBatch(requests, requestOptions, callback) {
        var effectiveCallback = typeof requestOptions === 'function' ? requestOptions : callback;

        var rpcRequests = requests.map(function (request) {
          return _extends({
            jsonrpc: '2.0'
          }, request);
        });

        var usedOptions = this.options;
        if ((typeof requestOptions === 'undefined' ? 'undefined' : _typeof(requestOptions)) === 'object') {
          usedOptions = _extends({}, usedOptions, requestOptions);
        }

        createTimeout(usedOptions.timeout, this.fetchURL(rpcRequests, usedOptions)).then(function (res) {
          return res.json();
        }).then(function (res) {
          if (res.length < 1) {
            throw new Error("Response doesn't contain results");
          }
          return res;
        }).then(function (res) {
          return effectiveCallback(null, res.map(function (singleResponse) {
            return singleResponse.result;
          }));
        }).catch(function (err) {
          return effectiveCallback(err, null);
        });
      }
    }]);
    return Client;
  }();

  return Client;

})));
